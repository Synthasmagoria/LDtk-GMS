<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// The path to the ldtk world to load (set in creation code)
world_path = "&lt; set in creation code &gt;";

// The key which you use to trigger LDtk reload
reload_key = ord("0");

//////////////////////////////////
//Internal shit from here on out//
//////////////////////////////////

// NOTE: Do not fuck around with this script unless you know exactly where its' implications lie and why
ldtk_level_relativity_set(true);

// NOTE: The first room start event this instance experiences will set a few variables
// This variable makes sure it doesn't happen twice
initialized = false;

// NOTE: A world manager object is tied to a room. Currently this means that for each ldtk world there needs to be a room
origin = room;

// NOTE: Currently this object is responsible for tracking what level should be loaded
previous_level_index = -1;
current_level_index = -1;

// These variables keep track of the world data and the associated caching
world = -1;
world_data = -1;
level_data = -1;

// The lua state machine that executes ldtk instance creation code
lua_state = -1;

// TODO: For v2.0 consider creating a special file format for room data that is quick to load and parse
// That way all the heavy lifting can happen in a compile step before the game has even been started

/*
    Current load order:
    Pre: 
    World: World -&gt; Definition Data Gathering (world_data) -&gt; IntGrid Object optimization
    Level: Level Instance Data (level_data)
    Restart: Level spawn (level_instance)
    
    Ideal load order:
    Pre: World
    World: Definition extraction -&gt; IntGrid Object optimization
    Level: Level Instance Data (level_data)
    Restart: Level spawn (level_instance)
*/

// TODO: Double check memory leaks
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Free memory
if (ds_exists(world, ds_type_map))
    ds_map_destroy(world);

if (ds_exists(world_data, ds_type_map))
    ds_map_destroy(world_data);

if (ds_exists(level_data, ds_type_map))
    ds_map_destroy(level_data);

if (lua_state_exists(lua_state))
    lua_state_destroy(lua_state);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// This will reload the world next restart
if (keyboard_check_pressed(reload_key))
    persistent = false;

if (current_level_index == -1)
    exit;

var _player = instance_find(ldtk_player_get(), 0);

if (_player == noone)
    exit;

// Do level transition and OOB checks
if (!ldtk_is_instance_in_level(ldtk_world_get_level(world, current_level_index), _player))
{
    var _next_level_index = ldtk_find_level_by_position(ds_map_find_value(world, "levels"), _player.x, _player.y);
    
    if (_next_level_index == -1)
    {
        with (_player)
        {
            script_execute(global.__ldtkgms_player_kill_script);
            show_debug_message("LDtk log: Killed player because they left the level bounds");
        }
    }
    else
    {
        // Create level that player has fallen into
        current_level_index = _next_level_index;
        show_debug_message("LDtk log: Outside level! Next level: " + string(current_level_index));
        room_restart();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!persistent)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check if in correct room

// Prevent duplicate objects and destroy if in wrong room
var _duplicate = false;

with (object_index)
    if (id != other.id &amp;&amp; origin == other.origin)
        _duplicate = true;

if (room != origin || _duplicate)
{
    instance_destroy();
    exit;
}

if (!initialized)
{
    origin = room;
    
    // TODO: Find a way do to the reading and parsing before getting to this point (its kinda heavy)
    world = ldtk_world_read(world_path);
    if (world == -1 || world == undefined)
    {
        instance_destroy(id, false);
        exit;
    }
    
    // NOTE: Documentation for these data structures has been moved to LDtk/world_data_empty.json and LDtk/level_data_empty.json
    world_data = ldtk_world_prepare(world);
    level_data = -1;
    
    // TODO: Evaluate if the state needs to be intialized on a world manager basis, or if there can just be a global one
    lua_state = lua_state_create();
    lua_ref_init(lua_state);
    
    initialized = true;
}

var _player = instance_find(ldtk_player_get(), 0);

// No level should be created when the room starts with no player in it
if (_player == noone)
{
    show_debug_message("LDtk log: No player in the room, couldn't spawn level");
    exit;
}

// No level should be created when the room starts with the player out of bounds
if (current_level_index == -1)
{
    current_level_index = ldtk_find_level_by_position(ds_map_find_value(world, "levels"), _player.x, _player.y);
}

// Create level if the player is inside a level bounds
if (current_level_index != -1)
{
    if (ds_exists(level_data, ds_type_map))
    {
        ds_map_destroy(level_data);
    }
    
    level_data = ldtk_level_prepare(world, __ldtk_iutil_ds_get(world, "levels", current_level_index), world_data);
    
    previous_level_index = current_level_index;
    
    ds_list_destroy(ldtk_level_create(world, __ldtk_iutil_ds_get(world, "levels", current_level_index), world_data, level_data, lua_state));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!persistent)
{
    // TODO: Add an alert for when no changes were found during reload
    var _reload_alert = "Reloading LDtk file. Restart room to apply changes.";
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    draw_set_alpha(1);
    __ldtk_iutil_draw_text_outline(
        4,
        surface_get_height(application_surface) - string_height(_reload_alert) - 4,
        _reload_alert,
        make_color_hsv((current_time / 10) % 255, 128, 255),
        c_black);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
